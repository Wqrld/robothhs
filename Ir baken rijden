

/// array's voor opslaan van meting van Ir baken///////////////////////////////////////////////
float arrayA2[12];
float arrayA5[12];
float arrayA3[12];
float arrayA4[12];
int p;
int q;
int r;
int s;
int maximaleA=0;
int maximaleB=0;
int maximaleC=0;
int maximaleD=0;
int maximale;
////functie voor het grootste getal van de IR Baken//////////////////////////////////////////
float GROOTSTE(){

  //doorloopt alle nummers in array A en pakt daar het max uit
for(int u = 0; u<12; u++) {
  p = arrayA[u];
  if (p > maximaleA) {
   maximaleA = p; 
  }
}
 //doorloopt alle nummers in array B en pakt daar het max uit
for(int k = 0; k<12; k++) {
  q = arrayB[k];
  if (q > maximaleB) {
   maximaleB = q; 
  } 
}
 //doorloopt alle nummers in array C en pakt daar het max uit
for(int l = 0; l<12; l++) {
  r = arrayC[l];
  if (r > maximaleC) {
   maximaleC = r; 
  } 
}
 //doorloopt alle nummers in array D en pakt daar het max uit
for(int m = 0; m<12; m++) {
  s = arrayC[m];
  if (s > maximaleD) {
   maximaleD = s; 
  } 
}
//kijken of ArrayA de grootste waarde van alle arrays heeft
if(p>q && p>r && p>s){
maximale = p;
}
//kijken of ArrayB de grootste waarde van alle arrays heeft
if (q>p && q>r && q>s){
maximale = q;
}
//kijken of ArrayC de grootste waarde van alle arrays heeft 
if(r>p && r>q && r>s){
maximale = r;
}
//kijken of ArrayD de grootste waarde van alle arrays heeft
if(s>p && s>q && s>r){
maximale = s;
}
Serial.println(maximale);
}
void setup() {
Serial.begin(9600);  
}    



/////  12 stappen van 7graden om alles rondom uit telezen (waar de IR baken staat)/////////
Void Draaien(){
    For(int G; G>=12; G++){
    ArrayA2[G] = analogRead(A2);
    ArrayA5[G] = analogRead(A5);
    ArrayA3[G] = analogRead(A3);
    ArrayA4[G] = analogRead(A4);    
    
    drive(FORWARD, 1);
    drive(FORWARD, 2);
    drive(BACKWARD, 3);
    drive(BACKWARD, 4);
    delay(500);
    drive(RELEASE, 1);
    drive(RELEASE, 2);
    drive(RELEASE, 3);
    drive(RELEASE, 4);
    
    }
}

Void positioneren(){
    For(int G; G>=12; G++){
    drive(FORWARD, 2);
    drive(BACKWARD, 3);
    delay(500)
    drive(RELEASE, 2);
    drive(RELEASE, 3);

        if(GROOTSTE == Sensorwaarde){
        break;
        }
    } 
}
  
Wat nog moet gebeuren is dat die dus draait totdat die de GROOTSTE gemeten waarden gelijk wordt
aan de waarde die dan opnieuw tijdens het draaien meet dan staat die met 1 van de sensoren naar de
grootste waarden moeten we alleen nog weten aan welke kant en dan kun je gaan rijden.
