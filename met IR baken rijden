#include <Servo.h>

//todo trigger pin echo pin distout distin
// linksachter motor2
// linksvoor M1
// rechtsvoor m4
// rechtsachter m3

#define LA 2
#define LV 1
#define RV 4
#define RA 3

//////////////////
// Docs voor AFMOTOR
// https://codebender.cc/library/AFMotor#AFMotor.cpp
//
// #define _BV(bit) (1 << (bit))
// #define bit(b) (1UL << (b))
//
/////////////////

// Sensors
#define EchoPin A0 // are these defined correctly? probably want to switch around
#define TriggerPin A1
#define ledSensor 9 // todo: setup and probably change port

// threshold voor hoe goed we de led moeten kunnen zien om te gaan rijden
#define threshold 50

// Bit positions in the 74HCT595 shift register output
#define MOTOR1_A 2
#define MOTOR1_B 3
#define MOTOR2_A 1
#define MOTOR2_B 4
#define MOTOR4_A 0
#define MOTOR4_B 6
#define MOTOR3_A 5
#define MOTOR3_B 7

// Arduino pin names for interface to 74HCT595 latch
#define MOTORLATCH 12
#define MOTORCLK 4
#define MOTORENABLE 7
#define MOTORDATA 8

// Constants that the user passes in to the motor calls
#define FORWARD 1
#define BACKWARD 2
#define RELEASE 4

#define LEFT 5
#define RIGHT 6
#define TurnLeft 7
#define TurnRight 8

// Motor frequency definitions (all 1khz, may be audible but best torque)
#define MOTOR12_1KHZ _BV(CS22)              // divide by 64
#define MOTOR34_1KHZ _BV(CS01) | _BV(CS00)  // divide by 64

// Servo
#define servoPin 10
Servo s;


// Stored the state of the shift register
static uint8_t latch_state;

// Poort indices voor de IR baken sensoren.
int arrayvoor[] = {A2};
int arraylinks[] = {A3};
int arrayachter[] = {A4};
int arrayrechts[] = {A5};

//2,3,4,5
//v,l,a,r


/******************************************
               MOTORS
******************************************/

// Timer registers:
// TCCR: timer control register, zegmaar alle settings
// OCR: output compare register, voor de duty cycle

// VGM20 & VGM21 bits: waveform generation. WGM20 en WGM21 op op 0b11 geven aan om fast pwm te gebruiken.
// Alternatief is phase correct pwm, zie https://docs.arduino.cc/tutorials/generic/secrets-of-arduino-pwm
// COMn* bits: Compare on match, enable/disable/invert output n
// in ons geval zetten we ze aan op non-inverted.

inline void initPWM1(uint8_t freq) {

  // use PWM from timer2A on PB3 (Arduino pin #11)
  TCCR2A |= _BV(COM2A1) | _BV(WGM20) | _BV(WGM21); // fast PWM, turn on oc2a
  TCCR2B = freq & 0x7;

  // Duty cycle op 0
  OCR2A = 0;


  pinMode(11, OUTPUT);

}

inline void initPWM2(uint8_t freq) {

  // use PWM from timer2B (pin 3)
  TCCR2A |= _BV(COM2B1) | _BV(WGM20) | _BV(WGM21); // fast PWM, turn on oc2b
  TCCR2B = freq & 0x7;

  // Duty cycle op 0
  OCR2B = 0;


  pinMode(3, OUTPUT);
}


inline void initPWM3(uint8_t freq) {

  // use PWM from timer0A / PD6 (pin 6)
  TCCR0A |= _BV(COM0A1) | _BV(WGM00) | _BV(WGM01); // fast PWM, turn on OC0A
  //TCCR0B = freq & 0x7;

  // Duty cycle op 0
  OCR0A = 0;

  pinMode(6, OUTPUT);
}

inline void initPWM4(uint8_t freq) {

  // use PWM from timer0B / PD5 (pin 5)
  TCCR0A |= _BV(COM0B1) | _BV(WGM00) | _BV(WGM01); // fast PWM, turn on oc0a
  //TCCR0B = freq & 0x7;

  // Duty cycle op 0
  OCR0B = 0;

  pinMode(5, OUTPUT);
}

// Set duty cycles
void setSpeed(uint8_t s) {
    // OCR = output compare register
    // Je timer telt op tot 255, en gaat uit als de waarde van het OCR* register gehaald is.
    // Hierdoor krijg je een duty cycle op een schaal van 0-255

  // motor 1, use PWM from timer2A on PB3 (Arduino pin #11)
  OCR2A = s;

  // motor 2, use PWM from timer2B (pin 3)
  OCR2B = s;

  // motor 3, use PWM from timer0A / PD6 (pin 6)
  OCR0A = s;

  // motor 4, use PWM from timer0B / PD5 (pin 5)
  OCR0B = s;
}


void initMotor(uint8_t num, uint8_t freq) {

  switch (num) {
    case 1:
      latch_state &= ~_BV(MOTOR1_A) & ~_BV(MOTOR1_B); // set both motor pins to 0
      latch_tx();
      initPWM1(freq);
      break;
    case 2:
      latch_state &= ~_BV(MOTOR2_A) & ~_BV(MOTOR2_B); // set both motor pins to 0
      latch_tx();
      initPWM2(freq);
      break;
    case 3:
      latch_state &= ~_BV(MOTOR3_A) & ~_BV(MOTOR3_B); // set both motor pins to 0
      latch_tx();
      initPWM3(freq);
      break;
    case 4:
      latch_state &= ~_BV(MOTOR4_A) & ~_BV(MOTOR4_B); // set both motor pins to 0
      latch_tx();
      initPWM4(freq);
      break;
  }
}

// TODO evt aanpassen voor de omgedraaide motoren?


void driveDirection(uint8_t cmd){
    if(cmd == FORWARD || cmd == BACKWARD || cmd == RELEASE){
        // We can just directly forward this to all our motors
        drive(cmd, LV);
        drive(cmd, LA);
        drive(cmd, RV);
        drive(cmd, RA);
    }else if(cmd == LEFT){
drive(FORWARD, LA);
drive(FORWARD, RA);
drive(BACKWARD, LV);
drive(BACKWARD, RV);
    }else if(cmd == RIGHT){
drive(BACKWARD, LA);
drive(BACKWARD, RA);
drive(FORWARD, LV);
drive(FORWARD, RV);
    }else if(cmd == TurnRight){
drive(FORWARD, LV);
drive(FORWARD, LA);
drive(BACKWARD, RV);
drive(BACKWARD, RA);

    }else if(cmd == TurnLeft){
drive(BACKWARD, LV);
drive(BACKWARD, LA);
drive(FORWARD, RV);
drive(FORWARD, RA);
    }
}

void drive(uint8_t cmd, uint8_t motornum) {
  uint8_t a, b;
  if((motornum == 2 || motornum == 3)){

if(cmd == FORWARD){
    cmd = BACKWARD;
}else if(cmd == BACKWARD){
    cmd = FORWARD;
}

  }

  //Decide which motor we should use
  switch (motornum) {
    case 1:
      a = MOTOR1_A; b = MOTOR1_B; break;
    case 2:
      a = MOTOR2_A; b = MOTOR2_B; break;
    case 3:
      a = MOTOR3_A; b = MOTOR3_B; break;
    case 4:
      a = MOTOR4_A; b = MOTOR4_B; break;
    default:
      return;
  }

  switch (cmd) {
    case FORWARD:
      latch_state |= _BV(a); // Set bit a to 1
      latch_state &= ~_BV(b);  //Set bit b to 0
      latch_tx();
      break;
    case BACKWARD:
      latch_state &= ~_BV(a); // Set bit a to 0
      latch_state |= _BV(b);  // Set bit b to 1
      latch_tx();
      break;
    case RELEASE:
      latch_state &= ~_BV(a);     // A and B both low (0)
      latch_state &= ~_BV(b);
      latch_tx();
      break;
  }
}

void latch_tx_short_untested(void) {
  // latch has to go low before transmitting
  digitalWrite(MOTORLATCH, LOW);
  // probably unneeded
  digitalWrite(MOTORDATA, LOW);
  // shift out the data, LSB first (untested, but matches the old latchtx)
  shiftOut(MOTORDATA, MOTORCLK, LSBFIRST, latch_state);
  // enable the latch again
  digitalWrite(MOTORLATCH, HIGH);
}

void latch_tx(void) {
  uint8_t i;

  //LATCH_PORT &= ~_BV(LATCH);
  digitalWrite(MOTORLATCH, LOW);

  //SER_PORT &= ~_BV(SER);
  digitalWrite(MOTORDATA, LOW);

  for (i = 0; i < 8; i++) {
    //CLK_PORT &= ~_BV(CLK);
    digitalWrite(MOTORCLK, LOW);

    if (latch_state & _BV(7 - i)) {
      //SER_PORT |= _BV(SER);
      digitalWrite(MOTORDATA, HIGH);
    } else {
      //SER_PORT &= ~_BV(SER);
      digitalWrite(MOTORDATA, LOW);
    }
    //CLK_PORT |= _BV(CLK);
    digitalWrite(MOTORCLK, HIGH);
  }
  //LATCH_PORT |= _BV(LATCH);
  digitalWrite(MOTORLATCH, HIGH);
}

/// array's voor opslaan van meting van Ir baken///////////////////////////////////////////////
float ArrayA2[12];
float ArrayA5[12];
float ArrayA3[12];
float ArrayA4[12];

float p;
float q;
float r;
float X;
float maximaleA=0;
float maximaleB=0;
float maximaleC=0;
float maximaleD=0;
float maximale;

////functie voor het grootste getal van de IR Baken//////////////////////////////////////////
float GROOTSTE(){
//doorloopt alle nummers in array A en pakt daar het max uit////////////////////////////////
for(int u = 0; u<12; u++) {
  p = ArrayA2[u];
  if (p > maximaleA) {
   maximaleA = p; 
  }
}
 //doorloopt alle nummers in array B en pakt daar het max uit//////////////////////////////////
for(int k = 0; k<12; k++) {
  q = ArrayA5[k];
  if (q > maximaleB) {
   maximaleB = q; 
  } 
}
 //doorloopt alle nummers in array C en pakt daar het max uit
for(int l = 0; l<12; l++) {
  r = ArrayA3[l];
  if (r > maximaleC) {
   maximaleC = r; 
  } 
}
 //doorloopt alle nummers in array D en pakt daar het max uit
for(int m = 0; m<12; m++) {
  X = ArrayA4[m];
  if (X > maximaleD) {
   maximaleD = X; 
  } 
}
//kijken of ArrayA de grootste waarde van alle arrays heeft
if(p>q && p>r && p>X){
maximale = p;
}
//kijken of ArrayB de grootste waarde van alle arrays heeft
if (q>p && q>r && q>X){
maximale = q;
}
//kijken of ArrayC de grootste waarde van alle arrays heeft 
if(r>p && r>q && r>X){
maximale = r;
}
//kijken of ArrayD de grootste waarde van alle arrays heeft
if(X>p && X>q && X>r){
maximale = X;
}
Serial.println(maximale);
return (maximale);
}


/////  12 stappen van 7graden om alles rondom uit telezen (waar de IR baken staat)///////////////////
void Draaien(){
    for(int G; G>=12; G++){
    ArrayA2[G] = analogRead(arrayvoor[G]);
    ArrayA5[G] = analogRead(arrayrechts[G]);
    ArrayA3[G] = analogRead(arraylinks[G]);
    ArrayA4[G] = analogRead(arrayachter[G]);    
    
    drive(FORWARD, 1);
    drive(FORWARD, 2);
    drive(BACKWARD, 3);
    drive(BACKWARD, 4);
    delay(500);
    drive(RELEASE, 1);
    drive(RELEASE, 2);
    drive(RELEASE, 3);
    drive(RELEASE, 4);
    delay(500);
    }
}

void positioneren(){
  for(int G; G>=12; G++){
  drive(FORWARD, 1);
  drive(FORWARD, 2);
  drive(BACKWARD, 3);
  drive(BACKWARD, 4);
  delay(500);
  drive(RELEASE, 1);
  drive(RELEASE, 2);
  drive(RELEASE, 3);
  drive(RELEASE, 4);
  delay(500);
        if(GROOTSTE() == maximaleA){ //voren
        break;
        }
        if(GROOTSTE() == maximaleB){ //rechts
        break;
        }
        if(GROOTSTE() == maximaleC){ //links
        break;
        }
        if(GROOTSTE() == maximaleD){ //achter
        break;
        }
    } 
///////////////////////hier moet die gaan rijden naar de kant dat 1 van de max het grootste is//////////

  if(GROOTSTE() == maximaleA){ //voren
  driveDirection(FORWARD);
  }
  if(GROOTSTE() == maximaleB){ //rechts
  driveDirection(RIGHT)
  ;
  }
  if(GROOTSTE() == maximaleC){ //links
  driveDirection(LEFT);
  }
  if(GROOTSTE() == maximaleD){ //achter
  driveDirection(BACKWARD);
  }
}
void setup() {
  
  
  
  // pinmodes sensors
  pinMode(TriggerPin, OUTPUT);
  pinMode(EchoPin, INPUT);
  pinMode(ledSensor, INPUT);

  // Servo
  s.attach(servoPin);

  // Motorcontroller
  pinMode(MOTORLATCH, OUTPUT);
  pinMode(MOTORENABLE, OUTPUT);
  pinMode(MOTORDATA, OUTPUT);
  pinMode(MOTORCLK, OUTPUT);

  latch_state = 0; // reset all motor states

  latch_tx();

  // Enable motor
  digitalWrite(MOTORENABLE, LOW);

  //1khz geeft de beste efficiency
  initMotor(1, MOTOR12_1KHZ); 
  initMotor(2, MOTOR12_1KHZ);
  initMotor(3, MOTOR34_1KHZ); 
  initMotor(4, MOTOR34_1KHZ); 
  
  // speed (duty cycle) up to 255, maar tot 128 veilig
  setSpeed(128); 

  //Possible options: FORWARD, BACKWARD, RELEASE, LEFT, RIGHT, TurnLeft, TurnRight
  driveDirection(TurnLeft);
  // Init serial output
  Serial.begin(9600);
  Serial.flush();

}

unsigned long getDistance() {

  // Send out 10microsecond pulse
  digitalWrite(TriggerPin, HIGH);
  delayMicroseconds(10);
  digitalWrite (TriggerPin, LOW);

  unsigned long duration = pulseIn(EchoPin, HIGH); // Find rtt duration

  unsigned long distance = duration * 0.034029 / 2; // Calculate distance
  return distance;
}

int getIRBrightness() {
  // Todo implement

  return 0;
}

// Run this from the main loop
void checkBlueTooth() {
  while(Serial.available() > 0){
   
    char input = (char) Serial.read();
    // pagina 32 voor de benodigde opdrachten, vb:
    
    // char, dus enkele aanhalingstekens
    if(input == 'F') {
     //rijnaarvoren(); 
    }
    
    // ....
    
    
    
    
    
  }
}

void loop() {
  Draaien();
  GROOTSTE();
  positioneren();
}
 
